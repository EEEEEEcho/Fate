### 微服务间安全通信SDK

该项目的实际需求是保护微服务之间通信是加密的（虽然这样做可能没有什么意义）。

首先说一下整体思路：项目整体采用加密认证体系为IBC，即基于身份标识的加密认证体系。在IBC体系下，不需要证书之类的文件，只需要每个参与的实体有唯一的身份标识即可。总的来说，该体系中有一个核心模块为密钥生成中心，该密钥生成中心通过预先配置的参数信息进行初始化，生成加密主公私钥、签名主公私钥以及密钥交换主公私钥。其他微服务在启动时，携带微服务名称作为身份标识，访问密钥生成中心提供的密钥下发API，密钥生成中心将由该身份标识生成的一些私钥信息返回给微服务的实例，微服务实例在本地进行保存。这里下发私钥信息时，是通过一定的规则生成一个对称密钥，用该对称密钥加密这些要下发的数据，然后接收方收到后以同样的规则生成对称密钥进行解密。

这个密钥申请的实现方式是在微服务实例启动时，检查数据库中有无已经分配好的参数，如果有，则不重新申请，否则重新申请，因为一个微服务可能存在多个实例，所以要对申请到的参数进行保存。采用的方法是，写一个类来实现ApplicationRunner接口，并重写其中的run方法，这样在微服务启动时就会执行run方法中的逻辑。



微服务之间的加密通信。在各个微服务申请好自己的私钥等信息之后，若要进行服务消费方与服务提供方之间的消息通信，首先需要进行握手过程。该握手过程一共分为三步，主要是进行三次参数交换，最后生成一个会话密钥，并以两个微服务名称以固定分割符还有一个标志位new拼接成一个字符串作为key，以存储到redis中，然后设置过期时间为1天，通过该会话密钥加密消息进行通信。两个服务之间第一次通信肯定首先要进行握手过程，但是握手过程是一个耗时的过程，这种时间损耗是无法接受的。因此采用的策略是首先在redis中给各个需要相互信的服务预置一个通用的会话密钥，格式是相同，只不过标志位设置为old。两个服务间发起通信时，首先判断两个服务之间标志位为new的会话密钥是否存在，如果不存在，那么直接用标志位为old的密钥加密，并开启一个线程发起握手，协商会话密钥，协商好之后，将标志位为old的会话密钥替换为握手出来的新的会话密钥。微服务间通信时则会使用握手协商出来的会话密钥对消息内容进行加密和解密。

微服务之间的握手过程。因为握手要分三部分执行，即两个微服务之间要进行多次的远程过程调用。但是由于一个微服务可能有多个实例，而且握手会产生很多中间结果需要进行保存。所以采用redis保存中间结果，并采用redis实现了一个分布式锁，保证微服务之间通信时，只能有一个实例进行握手。分布式锁的实现方法是采用redis的setnx方式，以通信双方微服务的名字作为锁名字，并设置过期时间，防止死锁的出现。

为了后续方便使用，将所有的握手逻辑进行了封装，并采用自定义注解的方式创建了一个切面，拦截由注解标注的方法，在注解中定义了第一次、第二次握手时的路径，在需要进行远程过程调用的方法上添加该注解就会发起握手，然后就可以通过在redis中获取会话密钥的方式进行加密通信。

再后来为了降低代码耦合性，将注解去掉，以类似的方式定义了一个类，封装好了所有的逻辑，从而更加方便地进行后续的调用。

### 军民融合车联网安全防护系统

该项目主要作用是开发了一套硬件系统能够实时加密发送车辆行驶信息，同时开发了一套软件系统来接受车辆行驶信息，对车辆信息进行实时监控，对行为异常的车辆发出报警信息以及下发固件升级指令升级车辆固件等。我参与的软件平台的开发。

基本流程为：车辆加装开发的Tbox硬件，并对该硬件在平台端进行注册，加装硬件后的车辆在启动时会向平台发起私钥信息等申请，平台方会根据硬件的注册信息以及约定好的预置密钥对私钥信息进行加密下发，下发后车端对私钥信息进行解密并存储，然后使用平台提供的私钥信息与平台发起握手，协商与平台通信时的会话密钥，完成协商之后，使用该会话密钥以及自定义的加密传输协议，进行数据上传。平台接收到数据后对数据进行解析和解密，并实时在前端展示车辆信息，对于出现的异常数据的车辆进行报警。

为保证系统的弹性和可用性，该车联网安全防护系统平台部分采用了微服务架构，以nacos作为服务注册心，以SpringGateway作为服务网关，包含了报警微服务、检测微服务、网关微服务、车辆升级微服务等在内的8个微服务。并采用netty框架接受车辆实时上传的数据。主要用到了SpringBoot 、mysql 、redis、netty、nacos等技术，用到了mybatis,fastjson,hutool等框架，下面对我自己所做的工作进行详细介绍。

首先我搭建了平台的整体框架和技术选型。依据平台功能进行了模块划分。供项目组其他参与者开发。

开发了KGC密钥生成中心微服务。本项目采用的加密认证体系为IBC，即基于身份标识的加密认证体系。在IBC体系下，不需要证书之类的文件，只需要每个参与的实体有唯一的身份标识即可。为了实现该密钥体系，采用了国产的SM9算法，目前已有较为成熟的实现，但是实现的jar包以及相关依赖的jar包在maven仓库中并不存在，因此需要手动安装到本地Maven仓库中。该微服务实现的功能主要是根据配置的参数初始化密钥生成中心。这里通过定义一个实现了ApplicationRunner接口的bean。在微服务启动时通过SM9算法，根据参数生成KGC必须的不同种类的主公钥、主私钥等，并存储到Mysql数据库中，若该微服务有多个实例，其他实例在启动时会先检查数据库中是否已经存在了这些参数，如果存在则跳过初始化操作。之后，实现了密钥申请的接口，车辆通过http请求访问该接口，以车辆自身的唯一标识Vin码作为请求参数，请求获取KGC根据其VIN码所生成的密钥信息，并通过该车辆的注册信息以约定好的算法生成一个预置密钥，用该密钥加密KGC生成的密钥信息，下发给车辆，车辆同样依据该算法生成预置密钥解密下发的消息并存储。

开发了握手微服务。该微服务主要提供两个接口用来处理与车辆的握手过程。握手主要分两步完成，因此车辆需要分两次按顺序请求两个接口。这里主要采用了SM9算法工具包实现了响应的握手逻辑。由于握手时会产生一些中间结果，第一次握手的结果第二次仍然需要使用，为了防止网关采用负载均衡时将请求发送至服务的不同实例，这里采用了redis作为缓存，缓存中间结果信息。在握手完成之后，也将生成的会话密钥缓存到redis中，并删除掉握手生成的中间信息。

开发了网关微服务，通过使用SpringGateway作为网关，通过断言在配置文件中配置了路由规则。因为项目也有前端界面，且采用的前后端分离的技术，为了解决带来的跨域问题，在网关微服务进行了CorsWebFilter的配置，解决了前后端分离的跨域问题。

使用Netty框架开发了接受车辆所上传的消息的模块。因为车辆在无加密条件下使用的是17691的明文协议，为了适配车端、减少车载终端的开发压力，采用的策略是将17691明文协议数据进行整体加密，然后自定义了一套加密协议，17691加密后的数据作为自定义加密协议的数据部分发送给Netty。由于Netty是一个异步的、事件驱动的框架，数据的处理都是由Netty中定义的Handler进行的。Netty是基于NIO的，底层使用的是Reactor模型，即使用Selector监测不同的事件，事件发生后进行处理。我在Netty中定义了三个NioEventLoopGroup。每个EventLoopGroup中存在多个EventLoop,一个EventLoop可以理解为一个线程，其中也包含了Selector。通俗一点可以将EventLoopGroup理解为线程池。这三个EventLoopGroup中有一个是用来专门处理连接事件，另一个专门处理Channel上的读写事件和Handler的调用。最后一个用来专门处理耗时的数据库存储操作。然后定义了一共八个Handler。这八个handler可以看做是一个channel上的流水线，车辆发送的消息以此经过这八个handler。首先第一个handler是Netty中提供的日志Handler，专门用来记录车辆上传的数据，并进行过打印。

第二个handler是Netty中的帧解码器。该帧解码器可以通过解析数据长度字段在数据包中的偏移量，取出整条数据，从而解决粘包和半包问题。

第三个handler为消息解码器，用来将提取出来的完整消息，按照协议的格式解析出来，并根据协议定义的格式，来判断该数据包是否符合规范，如果不符合规范，例如魔数或者版本号不正确，则抛弃数据。符合规范则传递给下一个Handler。

第四个handler和第五个handler共同处理心跳事件，因为车端是每10秒采集一次信息发送到云端，即每10秒有一次心跳。为避免因网络故障意外断开连接的车辆占用资源，这里使用了心跳监测机制，如果30秒内收不到车辆上传的消息，则服务器主动断开与车辆的连接，并删除redis中的会话密钥。

第六个handler为解密handler，因为车辆成功与平台握手之后，会将会话密钥存储在redis中，解密handler中会在redis中取出会话密钥，并对解析出来的数据部分进行解密。

第七个handler是协议解析handler，因为将整个17691协议作为加密协议的数据部分进行了封装，所以解密出来之后是完整的17691协议，协议解析handler将对解密之后的17691协议进行解析。解析之后，包含OBD信息，引擎信息等。为了保证前端每次都能实时监测车辆的状态，这里的设计方案是，将所有的引擎信息OBD信息中的重要信息，封装到一个Car对象中，每次有新的数据上传就回更新这个Car对象。那个引擎信息和OBD信息等直接存储。前端要监视车辆的实时情况，只需定时请求获取车辆信息的接口，即可获得车辆的最新信息。异常检测模块也会定时扫描在线车辆，对在线车辆的信息进行分析，如果有异常，则进行报告。同时在这个Handler中也会将该车辆的vin码与车辆的channel放到一个map中保留连接信息。同时，由于这部分操作可能较为耗时，为了不影响处理读写事件的EventLoop,这里是专门为该handler，提供了一个新的EventLoopGroup。

第八个handler用来处理车辆下线事件，捕捉正常和异常退出的车辆，关闭与该车辆的channel，并删除redis中的session key。



### 南广爱答小程序

南广爱答小程序是为中石油南充作业区开发的一款党史+技能答题的小程序。

主要由三部分组成：小程序端，小程序后台和小程序管理系统。

为了便于叙述，这里将小程序端和小程序后台的实现一起说。

##### 小程序端 + 小程序后台

小程序端主要采用的微信小程序技术，同时集成了一些自定义的组件进行开发。

小程序后台主要采用SpringBoot + mysql + redis实现。主要用到了mybatis框架、fastjson、hutool、和httpclient等工具。

主要分为登录/注册模块、新闻模块、答题模块和个人信息模块。

- 登录/注册模块
  - 小程序在打开之后，首先进入的是登录页面，进入登录页面后会要求输入手机号和密码，然后用户点击登录按钮进行登录。在点击登录按钮时，如果用户没有授权，会提醒用户进行授权操作，因为只有用户授权过后，才能获取该用户微信号的一些基本信息比如说临时登录码code，用来进行后续的请求。我这里用了一下微信小程序的缓存技术，因为小程序在关闭之后，一段时间内小程序的并不会清空缓存，所以再点击登录按钮时，如果用户已经打开过一次小程序，进行了授权，那么微信缓存中会有用户的信息，所以整体的逻辑是，用户输入手机号和密码，点击登录，并在小程序端进行参数校验，未经过参数校验会直接报错。然后判断小程序中是否缓存着用户的授权信息，如果有的话，就不需要进行授权，如果没有则需要进行授权操作，并将授权信息缓存到缓存中，然后将用户的用户名和密码以及用户登录后获取到的一些基本信息进行封装，然后使用post请求发送至后台进行校验，因为小程序原生的网络请求API大是异步的，所以在经过上网学习搜寻之后，对网络请求API进行了封装，封装成了同步方式的调用。为什么要封装成同步的呢？因为要根据后端返回的结果来判断是进行下一步的跳转还是错误信息的提示。
    小程序后端定义了接口，在接收到小程序提交的post请求之后，对请求参数进行解析。这里重要的参数是用户授权登陆后微信所提供的一个临时登录码code。后台在拿到这个临时登录码code之后，使用封装好的Httpclient的get方法，将这个code以及申请小程序后的一些小程序的必要参数信息，如小程序id等封装到一起，请求微信的服务器获取用户的openid和sessionkey,这个sessionkey后续不需要使用，因为不会用到用户的敏感信息。这个openid则是用来标识用户唯一身份的东西，在数据库中将这个openid作为了一个索引，并没有将它作为主键，因为这个openid并非单调递增的，不适合作为主键，会影响mysql的查询效率。mysql中所有数据的主键都是通过封装hutool工具包中的雪花算法生成的。好了，言归正传。在通过小程序传递过来的用户临时登陆凭证code，获取到用户的openid之后，再从数据库中进行查询，查询用户的手机号和密码，并进行校验。然后返回处理结果，处理结果包含正常和异常，根据可能发生的，如用户不存在、获取用户的openid失败等情况分别定义了不同的状态，返回给小程序端，供小程序端校验。
    小程序端根据后端返回的状态码和提示信息，进行跳转或者异常显示操作，后台会将其他业务所用到的必要的用户信息存入小程序的缓存中，同时删除掉之前缓存中存储的用户的登录信息。
  - 注册逻辑类似，点击按钮时，同样会要求用户进行授权。授权成功后进入注册页面，然后要求用户填写姓名、手机号、部门、密码、邀请码等信息。小程序端首先会进行参数的校验，如果参数填写错误，会显示相应的错误信息。然后以post请求的方式提交给后端。
    后端接收到请求之后，以同样的方式先根据用户的临时登陆凭证code，去访问微信的服务器，获取用户openid然后根据业务的一些基本要求进行用户的初始化，然后存入数据库中。
- 新闻模块
  - 小程序端新闻模块主要由新闻首页和新闻详情页组成，新闻首页采用了轮播图+新闻列表的方式进行展示。新闻首页在页面初始化时，会请求小程序后端的接口，返回新闻的简要信息，包括新闻id、标题、发布者，时间和图片。在新闻列表中的信息不展示图片，展示除ID之外的其余三项，在轮播图中的新闻只展示图片。当用户点击某个新闻或者轮播图中的图片时，会跳转到新闻的详情页，然后在详情页的时候，根据点击的新闻的id去请求后台接口，返回新闻的详细息。这样能够保证小程序不会占用太多的内存。
    这里说一下新闻图片的存储方式。新闻图片上传到的也是后台程序所运行的服务器上。但是上传时，同样使用了雪花算法对图片进行了重命名，固定存储到服务器上的一个专门存储新闻图片的文件夹下，然后将这个文件夹的路径使用SpringMVC的ResourceHandlerRegistry进行了虚拟映射，映射为了一个对外访问的路径，外部请求访问虚拟路径，然后映射到真正的本地图片。这样，在图片存储时，只需要存储图片文件的虚拟路径。
- 答题模块
  答题模块是小程序的核心，主要分为三个部分，有练习模式、刷题模式和实时排名。练习模式主要就是不限时不计分的从题库中随机选取题目练习。刷题模式则是计时、记分、影响段位。实时排名有两部分，一个是部门排名，一个是全体排名。
  - 练习模式，点击练习模式的时候，会首先从登陆成功后返回的用户信息（这些信息缓存到了微信小程序的内存中）中查看该用户的工种。新注册的用户工种是未选择的状态。如果用户的工种是未选择的状态，那么就会先进入工种选择的页面，让用户选择自己的工种，并存至缓存中。然后跳转到题目列表。题库列表中的题库和工种是一对一的关系，没有特殊技能的工种也会有题库，只不过就是党史类题库。然后题库列表中所展示的题库就是所有与该工种相关的题库，用户点击题库后，会进入答题页面，答题页面在初始化时，会根据选择的题库请求小程序的后台接口，随机从数据库中的相应题库抽取10到题目，将题目信息封装之后返回，小程序这边会存到小程序的数组中。（这里说一下题库，他们的题库都是word的形式，我自己写代码，通过正则表达式，将所有的题目从word中提取了出来，并进行格式化、封装，存入到了数据库中。）这里的随机选取做的并不好，参考了网上很多关于Mysql随机查询的例子，并且尝试了之后发现，网上很多的随机选取的实现，都不够随机，也就是说，每次查询到的题目都是那么几个固定范围内的题目。然后还是使用了最基本order by rand()的方式实现的，这种方式虽然随机性是够了，但是性能会很差。因为需要扫描全表，给记录打随机种子。其实更好的实现方式应该是在Java代码中做随机，然后带着随即后的结果去查数据库，但是我当时用了雪花算法，所以我当时没有很好的实现这种方法。还好题库数据量不大，性能影响不是很明显。
    剩余答题的逻辑就是单纯的判断用户所做的选择，和题目的正确答案是否匹配，然后通过设置一个index来控制下一题。当然，小程序也实现了错题功能，错题功能是通过在小程序的缓存中存储用户答错的题目。在用户答完全部题目之后，可以选择查看所有错题，跳到错题页，并把缓存取出来。依次展示。等用户离开错题页面转到答题页面时，清除缓存数据。这部分只是单纯的小程序前端操作和js函数的设计，因为没有涉及到用户的分数和段位变更。
  - 刷题模式，刷题模式和练习模式类似，但是功能要多一些，添加了倒计时功能和对用户分数和排名的更新操作。倒计时功能的主要思路是，定义一个递归函数，递归函数中对该页面加载时初始化的持续时间参数做每秒减一操作。如果是时间到了，则进行结果处理操作，并退出递归。同理，在固定的时间内完成了答题，也进行结果处理操作。结果处理主要是在每轮答题之后，根据用户的答题得分情况对用户数据进行更新，如分数，排名等。同时跟新缓存中的信息。这里可能要问了，排名信息如何更新呢？是通过对小程序发送给后台的更信息最为相应更新的。小程序向后台发送本轮答题后用户的分数情况，后台通过使用redis分别创建了两个zset结构，一个对应总榜的排名，一个对应部门的排名。然后根据小程序传递过来的用户openid,和分数去两个zset中重新更新值，并计算更新之后该用户的分数在所有用户中的排名，将该排名信息存储到数据库中，同时作为响应回传给小程序，小程序这边再根据相应更新小程序缓存中的用户信息。
  - 实时排名，实时排名则是从后台redis的两个zset中，返回排名最高的前十个。因为zset默认是按照分数递增的，所以要从后往前找前10个。
- 个人信息模块
  个人信息模块则是直接从小程序的缓存中，取出用户的个人信息进行展示。如果需要修改个人信息，则跳转到另一个页面，然后与注册逻辑类似，通过向后台发送post请求进行修改，修改成功之后，还将修改后的信息回传给小程序，存储到小程序的缓存中。.

##### 小程序管理系统

小程序管理系统同样采用Springboot + mysql + redis实现，框架类似。只不过是使用了Thymeleaf + bootstrap搭建了一套前台的界面。

主要是对用户的信息、题目信息、题库信息、工种信息之类的做增删改查操作。
其中主要有几个技术点：

- 登录认证。采用SpringSecurity对管理系统的登录进行了授权和认证控制。要求必须要有管理员权限的用户才能登录该系统，否则跳转到其他界面。
- 定时任务。业务要求每个月1号的凌晨1点执行一次分数清零、排名重置。所以采用了SpringBoot的定时任务，写了一个cron表达式来定期对redis中的排名信息进行删除，以及对数据库中所有用户的分数、段位、排名等进行重置操作。



