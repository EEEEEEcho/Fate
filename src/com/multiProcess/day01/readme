synchronized的底层实现：
JDK早期版本synchronized的实现是重量级的，synchronized需要去找操作系统申请线程
后来的改进
synchronized有一个锁升级的概念：
    我就是厕所所长（1，2）
sync(Obj),如果只有一个线程访问这个Obj时，hotspot会在这个对象头上markword记录这个线程ID，并没有实际加锁，这就是偏向锁
偏向锁:你是我的第一个，我偏着你点，我认为没有第二个线程来抢这把锁
如果出现线程争用，就会升级为自旋锁。
一个线程在那里通过偏向锁占着Obj，这时来了第二个线程争用这把锁，这时候，第二个线程发现锁被占用了。，
他就会通过一个类似while循环的东西不断请求，看看第一个线程是否还在占用，在这转圈检查，就叫自旋锁，最大的自旋次数是10
旋了10次以后还拿不到这个锁，就会升级为重量级锁，会请求操作系统，这时候线程一就不占用锁了。

如果某个加锁的对象的相应方法它执行时间特别长，且线程比较多，那么操作系统锁会很好用。
如果加锁的对象的相应方法执行时间段，线程数少，用自旋锁。

synchronized(Object)
这个Object,不能使用String常量,Integer,Object